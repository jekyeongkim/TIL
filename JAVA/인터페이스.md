## 인터페이스

---
### 인터페이스
무슨 기능을 만들어야 할까? vs 구현부터 하기 </br>
**어떤 기능부터 만들어야 할지부터 고민. 만들어야 할 기능들을 관련된 것끼리 묶은 후 이름을 지어준다**<br/><br/>
어떠한 기능을 만들어야 할지 고민하게 되는데 기능이 선언만 되어 있는 것 (메소드 구현 x)
```java
[public] interface 인터페이스 이름 {
    ...
}

// 예시
public interface User {
    ...
}
```
인터페이스 이름은 "Upper CamelCase"로 작성된다.</br>
인터페이스도 확장자는 .java</br>
**인터페이스의 모든 필드는 public static final이어야 하며, 모든 메소드는 public abstract 한다. (public static, abstract은 자동으로 선언되어 생략가능)<br>**
인터페이스를 구현하게 되면 반드시 인터페이스가 가지고 있는 메소드를 오버라이딩 할 필요가 있다.</br>
자바 8버전 이상부터는 디폴트(defualt) 메소드와 정적(static) 메소드도 선언이 가능하다.

---

### 로또번호 생성기 예시
필요한 기능들</br>
- 1~45 까지 써있는 볼을 로또 기계에 넣는다.<br>
- 로또 기계에 있는 볼들을 섞는다.<br>
- 섞인 볼들 중에서 6개를 꺼낸다.
1. LottoMachine 클래스
```java
public interface LottoMachin {
    int MAX_BALL_COUNT = 45; // (public static은 생략)
    int RETURN_BALL_COUNT = 6; // (public static은 생략)
    public void setBalls(Ball[] balls); // Ball[] 볼을 여러 개를 받겠다. (45개) (abstract은 생략)
    public void mix(); // 볼들을 섞는다. (abstract은 생략)
    public Ball[] getBalls(); // 6개의 볼들을 반환한다. (abstract은 생략)
}
```
2. Ball 클래스
```java

```
3. LottoMachineImpl 클래스
```java
// 인터페이스를 구현하게 되면 반드시 인터페이스가 가지고 있는 메소드를 오버라이딩 할 필요가 있다.
public class LottoMachineImpl implements LottoMachine {
    @Override
    public void setBalls(Ball[] balls) {
        
    }
    
    @Override
    public void mix() {
        
    }
    
    @Override
    public Ball[] getBalls() {
        return new Ball[0];
    }
}
```
---
### 좋은 객체 vs 나쁜 객체

좋은 객체란, 역할과 책임에 충실하면서 다른 객체와 잘 협력하여 동작하는 개체<br/>
나쁜 객체란, 여러가지 역할을 한 가지 객체에 부여하거나, 이름과 맞지 않는 속성과 기능을 가지도록 하거나, 제대로 동작하지 않는 객체<br/><br/>
**좋은 객체는 응집도는 높고 결합도(Coupling)는 낮다.**<br/><br/>
객체를 만들 때는 관련된 기능을 잘 모아서 가지고 있어야 하고, 객체와 객체 간 결합도는 낮춰야 함<br/>

<br/><br/>

>**Reference**
><br/>부부개발단 - 즐겁게 프로그래밍 배우기.