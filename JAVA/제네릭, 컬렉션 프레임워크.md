## 제네릭(generic)

---
### 제네릭(generic)
`<T>`는 제네릭과 관련된 부분이다.</br>
제네릭은 클래스 이름 뒤, 메소드 리턴 타입 앞에 붙을 수 있다.</br>
`<T>`부분은 T라는 이름의 제네릭 타입을 선언한다는 것을 의미한다.</br>
T는 Type의 약자이며 꼭 T를 쓸 필요는 없음.</br>

### 제네릭 장점
정해진 타입만 사용하도록 강제할 수 있다.</br>
타입을 강제함으로써 컴파일할 때 잘못된 타입의 값이 저장되는 것을 막을 수 있다.</br>
예를 들어, 문자열만 받도록 해놓으면 사용자는 문자열만 넣어야 함.


1. ObjectBox 클래스 (어떤 타입이든 담을 수 있는 상자)
```java
public class ObjectBox {
    private Object object;
    
    // getter, setter 메소드
    public void set(Object obj) {
        this.object = obj;
    }

    public Object get() {
        return this.object;
    }
}
```
2. ObjectBoxMain 클래스
```java
public class ObjectBoxMain {
    public static void main(String[] args) {
        ObjectBox box = new ObjectBox();
        box.set("kim");
        // String 타입으로 형변환
        String str = (String) box.get();
        System.out.println(str.toUpperCase());
        
        box.set(new Integer(5));
        Integer i = (Integer) box.get();
        System.out.println(i.intValue());
    }
}
```
```text
KIM
5
```

ObjectBox 는 Object 타입을 가질 수 있기 때문에 Object의 후손들이 들어갈 수 있다.</br>
하지만, 꺼낼 때는 Object 타입으로 리턴해주기 때문에 원래 타입으로 형변환을 해줘야 함 → 너무 번거로움 😠</br>
**→ 이래서 나온 것이 제네릭(generic)**
1. GenericBox 클래스
```java
// ✅ Generic이라는 클래스는 T라는 이름의 아직 정해지지 않은 타입을 쓰겠다라는 의미
public class GenericBox<T> {
    // 아직 정해져 있지 않은 T타입
    private T t;
    
    public void add(T obj){
        this.t = obj;
    }
    
    public T get(){
        return this.t;
    }
}
```
2. GenericBoxMain 클래스
```java
public class GenericBoxMain {
    public static void main(String[] args) {
        // ✅ T라는 아직 정해져 있지 않은 타입을 String 타입으로 쓰겠다 라는 의미 → 형 변환이 따로 필요 없음 😀
        GenericBox<String> genericBox = new GenericBox<>();
        genericBox.add("kim");
        String str = genericBox.get();
        System.out.println(str.toUpperCase());
        
//        genericBox.add(new Integer(5)); 이건 컴파일 오류가 발생 
//        이유❓ 이미 위에서 String만 담을 수 있는 genericBox로 선언했기 때문
        
        // Integer 타입을 담으려면 다시 선언해줘야 함
        GenericBox<Integer> intBox = new GenericBox<>();
        genericBox.add(new Integer(5));
        Integer intValue = intBox.get();
        System.out.println(intValue);
    }
}
```
```text
KIM
5
```
***generic 이라는 문법을 사용하게 되면 내가 원하는 타입을 지정할 수가 있으며 받고 리턴할 수가 있다!!!***</br>

---

### 컬렉션 프레임워크(Collection Framework)

**자료(Data)를 다룰 때 반드시 필요한 클래스의 모음</br>**
**5가지 인터페이스 (Collection, Iterator, List, Set, Map)**

![img_3.png](img_3.png) 


---

### Collection 인터페이스
여기에 자료가 있다라는 것을 표현하는 인터페이스, 바구니</br>
컬렉션 프레임워크에서 가장 기본이 되는 인터페이스</br>
**해당 인터페이스는 순서를 기억하지 않고, 중복을 허용하여 자료를 다루는 목적으로 만들어짐**
- `add(Object) : boolean` 메소드 (물건을 담는)</br>
- `size() : int` 메소드 (물건이 몇 개 있는지?)</br>
- `iterator() : Iterator` 메소드 (바구니에 물건을 집어 넣었지만 순서를 기억 못함 → `iterator()` 메소드 활용)

---

### Iterator 인터페이스
물건을 꺼내는 인터페이스</br>
모든 것을 꺼내기 위한 패턴(디자인 패턴)</br>
- `hasNext() : boolean` 메소드 (꺼낼 것이 있는지 없는지?)</br>
- `next() : Object` 메소드 (하나를 꺼낸다, 다음 것을 꺼낸다)</br>
- `hasNext()`로 꺼낼 것이 있는지 확인 후, `next()`로 꺼냄

Collection은 어떠한 값이 있다라는 것만 표현하고 순서 자체를 기억 못함.</br>
→ Collection 에 들어있는 것을 다 꺼내기 위해서는 Iterator를 리턴해주는데 그것을 이용해 꺼냄</br>
**→ Collection은 모든 것을 꺼내기 위해 Iterator에 의존한다❗️❗️❗️**

---

### List 인터페이스 (Collection을 상속)
물건을 담아두기 위한 인터페이스</br>
**순서를 기억하는 자료구조(데이터를 저장할 수 있는 객체)**</br>
순서가 중요한 자료를 다룰 때 사용하는 인터페이스</br>
Collection을 상속받음으로써 Collection이 갖고 있는 `add()`, `size()`, `iterator()` 메소드를 사용할 수 있다.</br>
해당 인터페이스는 순서를 알고 있다고 가정하기 때문에 특정 순서로 저장된 자료를 꺼낼 수 있는 `get(int)` 메소드를 갖고 있다.</br>
몇 번째 추가된 자료인지 알 수가 있음
- Collection을 상속받고 있기 때문에, `add()`, `iterator()`, `size()` 메소드를 갖고 있음
- `get(int) : Object` 메소드 (순서를 기억하기 때문에 순서를 받아들여 꺼낸다)

### ArrayList (List 인터페이스를 구현하고 있는 클래스)

---

### Set 인터페이스 (Collection을 상속)
**중복을 허용하지 않는 자료구조**</br>
같은 값이 들어오면 무조건 한 건만 저장</br>
1 ~ 10까지 3번 연속 저장하려 함(1, 1, 1, 2, 2, 2 ... 10, 10, 10) → 하지만 1 ~ 10까지 10개의 데이터만 저장됨 (1, 2, 3 ... 10) 
- `add(Object) : boolean` 메소드 (물건을 담는)

### HashSet (Set 인터페이스를 구현하고 있는 클래스)

---

### Map 인터페이스
**Key와 Value(값)로 구성되어 있는 자료구조**
- `put(Object, Object) : void` 메소드 (첫 번째 파라미터는 Key값, 두 번쨰 파라미터는 Value값)
- `get(Object) : Object` 메소드 (파라미터로 Key값을 넣으면 Key에 해당하는 Value값을 리턴, Key에 해당하는 값이 없으면 null 리턴)
- `keySet() : Set` 메소드 (`put(Object, Object)` 메소드로 여러 건을 저장하게 되면, Key값들만 모아놓은 Set을 리턴 → 중복을 허용하지 않음)

Set안에 들어있는 모든 Key값을 꺼내고 싶으면❓</br>
→ Set의 부모인 Collection이 갖고 있는 Iterator를 이용(`hasNext()`, `next()`)하여 모든 Key를 꺼낼 수 있음.

### HashMap (Map 인터페이스를 구현하고 있는 클래스)



<br/><br/>

>**Reference**
><br/>부부개발단 - 즐겁게 프로그래밍 배우기.