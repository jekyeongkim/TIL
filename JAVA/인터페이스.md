## 인터페이스

---
### 인터페이스
무슨 기능을 만들어야 할까? vs 구현부터 하기 </br>
**어떤 기능부터 만들어야 할지부터 고민. 만들어야 할 기능들을 관련된 것끼리 묶은 후 이름을 지어준다**<br/><br/>
어떠한 기능을 만들어야 할지 고민하게 되는데 기능이 선언만 되어 있는 것 (메소드 구현 x)
```java
[public] interface 인터페이스 이름 {
    ...
}

// 예시
public interface User {
    ...
}
```
인터페이스 이름은 "Upper CamelCase"로 작성된다.</br>
인터페이스도 확장자는 .java</br>
**인터페이스의 모든 필드는 public static final이어야 하며, 모든 메소드는 public abstract 한다. (public static, abstract은 자동으로 선언되어 생략가능)<br>**
인터페이스를 구현하게 되면 반드시 인터페이스가 가지고 있는 메소드를 오버라이딩 할 필요가 있다.</br>
자바 8버전 이상부터는 디폴트(defualt) 메소드와 정적(static) 메소드도 선언이 가능하다.

---

### 로또번호 생성기 예시
필요한 기능들</br>
- 1~45 까지 써있는 볼을 로또 기계에 넣는다.<br>
- 로또 기계에 있는 볼들을 섞는다.<br>
- 섞인 볼들 중에서 6개를 꺼낸다.
1. LottoMachine 클래스
```java
public interface LottoMachin {
    int MAX_BALL_COUNT = 45; // (public static은 생략)
    int RETURN_BALL_COUNT = 6; // (public static은 생략)
    public void setBalls(Ball[] balls); // Ball[] 볼을 여러 개를 받겠다. (45개) (abstract은 생략)
    public void mix(); // 볼들을 섞는다. (abstract은 생략)
    public Ball[] getBalls(); // 6개의 볼들을 반환한다. (abstract은 생략)
}
```
2. Ball 클래스
```java
// 생성자에서 어떤 초기값을 넣어준 뒤 필드를 초기화 해주고 값을 리턴만 해주는 클래스 → 불변캑체
public class Ball {
    private int number;
    
    // 생성자
    public Ball(int number) {
        this.number = number;
    }
    
    // getter 메소드
    public int getNumber() {
        return number;
    }
}
```
3. LottoMachineImpl 클래스 (LottoMachine 인터페이스 클래스의 구현체)
```java
// 인터페이스를 구현하게 되면 반드시 인터페이스가 가지고 있는 메소드를 오버라이딩 할 필요가 있다.
public class LottoMachineImpl implements LottoMachine {
    // 아래 Ball[]을 받는 메소드가 있기 때문에 필드 선언해줘야 함
    private Ball[] balls;
    
    @Override
    public void setBalls(Ball[] balls) {
        this.balls = balls;
    }
    
    // Math.random() 메소드는 0.0 <= x < 1.0의 실수값이 나오게 해줌
    @Override
    public void mix() {
        for (int i = 0; i < 10000; i++) {
            int x1 = (int)(Math.random() * LottoMachine.MAX_BALL_COUNT); // 45를 곱해준 뒤 int로 변환
            int x2 = (int)(Math.random() * LottoMachine.MAX_BALL_COUNT);
            
            if (x1 != x2) {
                Ball tmp = balls[x1]; // 값을 치환할 때는 같은 type의 임시변수가 필요
                balls[x1] = balls[x2]; // balls[x2]가 참조하는 것을 balls[x1] 참조하도록
                balls[x2] = tmp; // balls[x2]에 tmp값을 다시 넣어줌
            }
        }
    }
    
    @Override
    public Ball[] getBalls() {
        Ball[] result = new Ball[LottoMachine.RETURN_BALL_COUNT]; // 볼 6개를 참조할 수 있는 배열
        for (int i = 0; i < LottoMachine.RETURN_BALL_COUNT; i++) {
            result[i] = balls[i]; // 위의 mix() 메소드에 의해 볼들이 섞여있기 때문에 i번째까지 볼들 result에 담음
        }
        return result;
    }
}
```
4. LottoMachineMain 클래스
```java
public class LottoMachineMain {
    public static void main(String[] args) {
//        Ball b1 = new Ball(1);
//        Ball b1 = new Ball(2);
//        ....
//        Ball b1 = new Ball(45);
        
        // 위처럼 변수가 여러 개씩(45개) 필요하다. → 배열을 사용하는 것이 좋음
        Ball[] balls = new Ball[LottoMachine.MAX_BALL_COUNT]; // Ball 인스턴스를 45개 참조할 수 있는 배열
        balls[0] = new Ball(1);
//        balls[0] = new Ball[1];
//        balls[1] = new Ball[2];
//        balls[44] = new Ball[45];
        
        // 위처럼 적어줘야 하는게 맞지만 반복문을 통해 처리하는 것이 더 적합해보임
        for (int i = 0; i < LottoMachine.MAX_BALL_COUNT; i++) { // 0부터 44까지 반복
            balls[i] = new Ball(i + 1);
        }
        
        // LottoMachine 인스턴스가 생성된다.
        // LottoMachine 인터페이스를 구현하고 있는 인스턴스를 생성하고 LottoMachine을 참조
        LottoMachine lottoMachine = new LottoMachineImpl();
        lottoMachine.setBalls(balls);
        lottoMachine.mix();
        Ball[] result = lottoMachine.getBalls();
        
        for (int i = 0; i < result.length; i++) {
            System.out.println(result[i].getNumber());
        }
    }
}
```
---


<br/><br/>

>**Reference**
><br/>부부개발단 - 즐겁게 프로그래밍 배우기.